// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// Scraped Content is the forming union over the different scrapers
type ScrapedContent interface {
	IsScrapedContent()
}

type AddTempDLNAIPInput struct {
	Address string `json:"address"`
	// Duration to enable, in minutes. 0 or null for indefinite.
	Duration *int `json:"duration"`
}

type AutoTagMetadataInput struct {
	// Paths to tag, null for all files
	Paths []string `json:"paths"`
	// IDs of performers to tag files with, or "*" for all
	Performers []string `json:"performers"`
	// IDs of studios to tag files with, or "*" for all
	Studios []string `json:"studios"`
	// IDs of tags to tag files with, or "*" for all
	Tags []string `json:"tags"`
}

type AutoTagMetadataOptions struct {
	// IDs of performers to tag files with, or "*" for all
	Performers []string `json:"performers"`
	// IDs of studios to tag files with, or "*" for all
	Studios []string `json:"studios"`
	// IDs of tags to tag files with, or "*" for all
	Tags []string `json:"tags"`
}

type BackupDatabaseInput struct {
	Download *bool `json:"download"`
}

type BulkGalleryUpdateInput struct {
	ClientMutationID *string        `json:"clientMutationId"`
	Ids              []string       `json:"ids"`
	URL              *string        `json:"url"`
	Date             *string        `json:"date"`
	Details          *string        `json:"details"`
	Rating           *int           `json:"rating"`
	Organized        *bool          `json:"organized"`
	SceneIds         *BulkUpdateIds `json:"scene_ids"`
	StudioID         *string        `json:"studio_id"`
	TagIds           *BulkUpdateIds `json:"tag_ids"`
	PerformerIds     *BulkUpdateIds `json:"performer_ids"`
}

type BulkImageUpdateInput struct {
	ClientMutationID *string        `json:"clientMutationId"`
	Ids              []string       `json:"ids"`
	Title            *string        `json:"title"`
	Rating           *int           `json:"rating"`
	Organized        *bool          `json:"organized"`
	StudioID         *string        `json:"studio_id"`
	PerformerIds     *BulkUpdateIds `json:"performer_ids"`
	TagIds           *BulkUpdateIds `json:"tag_ids"`
	GalleryIds       *BulkUpdateIds `json:"gallery_ids"`
}

type BulkMovieUpdateInput struct {
	ClientMutationID *string  `json:"clientMutationId"`
	Ids              []string `json:"ids"`
	Rating           *int     `json:"rating"`
	StudioID         *string  `json:"studio_id"`
	Director         *string  `json:"director"`
}

type BulkPerformerUpdateInput struct {
	ClientMutationID *string        `json:"clientMutationId"`
	Ids              []string       `json:"ids"`
	URL              *string        `json:"url"`
	Gender           *GenderEnum    `json:"gender"`
	Birthdate        *string        `json:"birthdate"`
	Ethnicity        *string        `json:"ethnicity"`
	Country          *string        `json:"country"`
	EyeColor         *string        `json:"eye_color"`
	Height           *string        `json:"height"`
	Measurements     *string        `json:"measurements"`
	FakeTits         *string        `json:"fake_tits"`
	CareerLength     *string        `json:"career_length"`
	Tattoos          *string        `json:"tattoos"`
	Piercings        *string        `json:"piercings"`
	Aliases          *string        `json:"aliases"`
	Twitter          *string        `json:"twitter"`
	Instagram        *string        `json:"instagram"`
	Favorite         *bool          `json:"favorite"`
	TagIds           *BulkUpdateIds `json:"tag_ids"`
	Rating           *int           `json:"rating"`
	Details          *string        `json:"details"`
	DeathDate        *string        `json:"death_date"`
	HairColor        *string        `json:"hair_color"`
	Weight           *int           `json:"weight"`
	IgnoreAutoTag    *bool          `json:"ignore_auto_tag"`
}

type BulkSceneUpdateInput struct {
	ClientMutationID *string        `json:"clientMutationId"`
	Ids              []string       `json:"ids"`
	Title            *string        `json:"title"`
	Details          *string        `json:"details"`
	URL              *string        `json:"url"`
	Date             *string        `json:"date"`
	Rating           *int           `json:"rating"`
	Organized        *bool          `json:"organized"`
	StudioID         *string        `json:"studio_id"`
	GalleryIds       *BulkUpdateIds `json:"gallery_ids"`
	PerformerIds     *BulkUpdateIds `json:"performer_ids"`
	TagIds           *BulkUpdateIds `json:"tag_ids"`
	MovieIds         *BulkUpdateIds `json:"movie_ids"`
}

type BulkUpdateIds struct {
	Ids  []string         `json:"ids"`
	Mode BulkUpdateIDMode `json:"mode"`
}

type CleanMetadataInput struct {
	Paths []string `json:"paths"`
	// Do a dry run. Don't delete any files
	DryRun bool `json:"dryRun"`
}

type ConfigDLNAInput struct {
	ServerName *string `json:"serverName"`
	// True if DLNA service should be enabled by default
	Enabled *bool `json:"enabled"`
	// List of IPs whitelisted for DLNA service
	WhitelistedIPs []string `json:"whitelistedIPs"`
	// List of interfaces to run DLNA on. Empty for all
	Interfaces []string `json:"interfaces"`
}

type ConfigDLNAResult struct {
	ServerName string `json:"serverName"`
	// True if DLNA service should be enabled by default
	Enabled bool `json:"enabled"`
	// List of IPs whitelisted for DLNA service
	WhitelistedIPs []string `json:"whitelistedIPs"`
	// List of interfaces to run DLNA on. Empty for all
	Interfaces []string `json:"interfaces"`
}

type ConfigDefaultSettingsInput struct {
	Scan     *ScanMetadataInput     `json:"scan"`
	Identify *IdentifyMetadataInput `json:"identify"`
	AutoTag  *AutoTagMetadataInput  `json:"autoTag"`
	Generate *GenerateMetadataInput `json:"generate"`
	// If true, delete file checkbox will be checked by default
	DeleteFile *bool `json:"deleteFile"`
	// If true, delete generated files checkbox will be checked by default
	DeleteGenerated *bool `json:"deleteGenerated"`
}

type ConfigDefaultSettingsResult struct {
	Scan     *ScanMetadataOptions         `json:"scan"`
	Identify *IdentifyMetadataTaskOptions `json:"identify"`
	AutoTag  *AutoTagMetadataOptions      `json:"autoTag"`
	Generate *GenerateMetadataOptions     `json:"generate"`
	// If true, delete file checkbox will be checked by default
	DeleteFile *bool `json:"deleteFile"`
	// If true, delete generated supporting files checkbox will be checked by default
	DeleteGenerated *bool `json:"deleteGenerated"`
}

type ConfigDisableDropdownCreate struct {
	Performer bool `json:"performer"`
	Tag       bool `json:"tag"`
	Studio    bool `json:"studio"`
}

type ConfigDisableDropdownCreateInput struct {
	Performer *bool `json:"performer"`
	Tag       *bool `json:"tag"`
	Studio    *bool `json:"studio"`
}

type ConfigGeneralInput struct {
	// Array of file paths to content
	Stashes []*StashConfigInput `json:"stashes"`
	// Path to the SQLite database
	DatabasePath *string `json:"databasePath"`
	// Path to generated files
	GeneratedPath *string `json:"generatedPath"`
	// Path to import/export files
	MetadataPath *string `json:"metadataPath"`
	// Path to scrapers
	ScrapersPath *string `json:"scrapersPath"`
	// Path to cache
	CachePath *string `json:"cachePath"`
	// Whether to calculate MD5 checksums for scene video files
	CalculateMd5 *bool `json:"calculateMD5"`
	// Hash algorithm to use for generated file naming
	VideoFileNamingAlgorithm *HashAlgorithm `json:"videoFileNamingAlgorithm"`
	// Number of parallel tasks to start during scan/generate
	ParallelTasks *int `json:"parallelTasks"`
	// Include audio stream in previews
	PreviewAudio *bool `json:"previewAudio"`
	// Number of segments in a preview file
	PreviewSegments *int `json:"previewSegments"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration *float64 `json:"previewSegmentDuration"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart *string `json:"previewExcludeStart"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd *string `json:"previewExcludeEnd"`
	// Preset when generating preview
	PreviewPreset *PreviewPreset `json:"previewPreset"`
	// Max generated transcode size
	MaxTranscodeSize *StreamingResolutionEnum `json:"maxTranscodeSize"`
	// Max streaming transcode size
	MaxStreamingTranscodeSize *StreamingResolutionEnum `json:"maxStreamingTranscodeSize"`
	// Write image thumbnails to disk when generating on the fly
	WriteImageThumbnails *bool `json:"writeImageThumbnails"`
	// Username
	Username *string `json:"username"`
	// Password
	Password *string `json:"password"`
	// Maximum session cookie age
	MaxSessionAge *int `json:"maxSessionAge"`
	// Comma separated list of proxies to allow traffic from
	TrustedProxies []string `json:"trustedProxies"`
	// Name of the log file
	LogFile *string `json:"logFile"`
	// Whether to also output to stderr
	LogOut *bool `json:"logOut"`
	// Minimum log level
	LogLevel *string `json:"logLevel"`
	// Whether to log http access
	LogAccess *bool `json:"logAccess"`
	// True if galleries should be created from folders with images
	CreateGalleriesFromFolders *bool `json:"createGalleriesFromFolders"`
	// Array of video file extensions
	VideoExtensions []string `json:"videoExtensions"`
	// Array of image file extensions
	ImageExtensions []string `json:"imageExtensions"`
	// Array of gallery zip file extensions
	GalleryExtensions []string `json:"galleryExtensions"`
	// Array of file regexp to exclude from Video Scans
	Excludes []string `json:"excludes"`
	// Array of file regexp to exclude from Image Scans
	ImageExcludes []string `json:"imageExcludes"`
	// Custom Performer Image Location
	CustomPerformerImageLocation *string `json:"customPerformerImageLocation"`
	// Scraper user agent string
	ScraperUserAgent *string `json:"scraperUserAgent"`
	// Scraper CDP path. Path to chrome executable or remote address
	ScraperCDPPath *string `json:"scraperCDPPath"`
	// Whether the scraper should check for invalid certificates
	ScraperCertCheck *bool `json:"scraperCertCheck"`
	// Stash-box instances used for tagging
	StashBoxes []*StashBoxInput `json:"stashBoxes"`
	// Python path - resolved using path if unset
	PythonPath *string `json:"pythonPath"`
}

type ConfigGeneralResult struct {
	// Array of file paths to content
	Stashes []*StashConfig `json:"stashes"`
	// Path to the SQLite database
	DatabasePath string `json:"databasePath"`
	// Path to generated files
	GeneratedPath string `json:"generatedPath"`
	// Path to import/export files
	MetadataPath string `json:"metadataPath"`
	// Path to the config file used
	ConfigFilePath string `json:"configFilePath"`
	// Path to scrapers
	ScrapersPath string `json:"scrapersPath"`
	// Path to cache
	CachePath string `json:"cachePath"`
	// Whether to calculate MD5 checksums for scene video files
	CalculateMd5 bool `json:"calculateMD5"`
	// Hash algorithm to use for generated file naming
	VideoFileNamingAlgorithm HashAlgorithm `json:"videoFileNamingAlgorithm"`
	// Number of parallel tasks to start during scan/generate
	ParallelTasks int `json:"parallelTasks"`
	// Include audio stream in previews
	PreviewAudio bool `json:"previewAudio"`
	// Number of segments in a preview file
	PreviewSegments int `json:"previewSegments"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration float64 `json:"previewSegmentDuration"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart string `json:"previewExcludeStart"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd string `json:"previewExcludeEnd"`
	// Preset when generating preview
	PreviewPreset PreviewPreset `json:"previewPreset"`
	// Max generated transcode size
	MaxTranscodeSize *StreamingResolutionEnum `json:"maxTranscodeSize"`
	// Max streaming transcode size
	MaxStreamingTranscodeSize *StreamingResolutionEnum `json:"maxStreamingTranscodeSize"`
	// Write image thumbnails to disk when generating on the fly
	WriteImageThumbnails bool `json:"writeImageThumbnails"`
	// API Key
	APIKey string `json:"apiKey"`
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// Maximum session cookie age
	MaxSessionAge int `json:"maxSessionAge"`
	// Comma separated list of proxies to allow traffic from
	TrustedProxies []string `json:"trustedProxies"`
	// Name of the log file
	LogFile *string `json:"logFile"`
	// Whether to also output to stderr
	LogOut bool `json:"logOut"`
	// Minimum log level
	LogLevel string `json:"logLevel"`
	// Whether to log http access
	LogAccess bool `json:"logAccess"`
	// Array of video file extensions
	VideoExtensions []string `json:"videoExtensions"`
	// Array of image file extensions
	ImageExtensions []string `json:"imageExtensions"`
	// Array of gallery zip file extensions
	GalleryExtensions []string `json:"galleryExtensions"`
	// True if galleries should be created from folders with images
	CreateGalleriesFromFolders bool `json:"createGalleriesFromFolders"`
	// Array of file regexp to exclude from Video Scans
	Excludes []string `json:"excludes"`
	// Array of file regexp to exclude from Image Scans
	ImageExcludes []string `json:"imageExcludes"`
	// Custom Performer Image Location
	CustomPerformerImageLocation *string `json:"customPerformerImageLocation"`
	// Scraper user agent string
	ScraperUserAgent *string `json:"scraperUserAgent"`
	// Scraper CDP path. Path to chrome executable or remote address
	ScraperCDPPath *string `json:"scraperCDPPath"`
	// Whether the scraper should check for invalid certificates
	ScraperCertCheck bool `json:"scraperCertCheck"`
	// Stash-box instances used for tagging
	StashBoxes []*StashBox `json:"stashBoxes"`
	// Python path - resolved using path if unset
	PythonPath string `json:"pythonPath"`
}

type ConfigImageLightboxInput struct {
	SlideshowDelay             *int                      `json:"slideshowDelay"`
	DisplayMode                *ImageLightboxDisplayMode `json:"displayMode"`
	ScaleUp                    *bool                     `json:"scaleUp"`
	ResetZoomOnNav             *bool                     `json:"resetZoomOnNav"`
	ScrollMode                 *ImageLightboxScrollMode  `json:"scrollMode"`
	ScrollAttemptsBeforeChange *int                      `json:"scrollAttemptsBeforeChange"`
}

type ConfigImageLightboxResult struct {
	SlideshowDelay             *int                      `json:"slideshowDelay"`
	DisplayMode                *ImageLightboxDisplayMode `json:"displayMode"`
	ScaleUp                    *bool                     `json:"scaleUp"`
	ResetZoomOnNav             *bool                     `json:"resetZoomOnNav"`
	ScrollMode                 *ImageLightboxScrollMode  `json:"scrollMode"`
	ScrollAttemptsBeforeChange int                       `json:"scrollAttemptsBeforeChange"`
}

type ConfigInterfaceInput struct {
	// Ordered list of items that should be shown in the menu
	MenuItems []string `json:"menuItems"`
	// Enable sound on mouseover previews
	SoundOnPreview *bool `json:"soundOnPreview"`
	// Show title and tags in wall view
	WallShowTitle *bool `json:"wallShowTitle"`
	// Wall playback type
	WallPlayback *string `json:"wallPlayback"`
	// Show scene scrubber by default
	ShowScrubber *bool `json:"showScrubber"`
	// Maximum duration (in seconds) in which a scene video will loop in the scene player
	MaximumLoopDuration *int `json:"maximumLoopDuration"`
	// If true, video will autostart on load in the scene player
	AutostartVideo *bool `json:"autostartVideo"`
	// If true, video will autostart when loading from play random or play selected
	AutostartVideoOnPlaySelected *bool `json:"autostartVideoOnPlaySelected"`
	// If true, next scene in playlist will be played at video end by default
	ContinuePlaylistDefault *bool `json:"continuePlaylistDefault"`
	// If true, studio overlays will be shown as text instead of logo images
	ShowStudioAsText *bool `json:"showStudioAsText"`
	// Custom CSS
	CSS        *string `json:"css"`
	CSSEnabled *bool   `json:"cssEnabled"`
	// Interface language
	Language *string `json:"language"`
	// Slideshow Delay
	SlideshowDelay *int                      `json:"slideshowDelay"`
	ImageLightbox  *ConfigImageLightboxInput `json:"imageLightbox"`
	// Set to true to disable creating new objects via the dropdown menus
	DisableDropdownCreate *ConfigDisableDropdownCreateInput `json:"disableDropdownCreate"`
	// Handy Connection Key
	HandyKey *string `json:"handyKey"`
	// Funscript Time Offset
	FunscriptOffset *int `json:"funscriptOffset"`
	// True if we should not auto-open a browser window on startup
	NoBrowser *bool `json:"noBrowser"`
	// True if we should send notifications to the desktop
	NotificationsEnabled *bool `json:"notificationsEnabled"`
}

type ConfigInterfaceResult struct {
	// Ordered list of items that should be shown in the menu
	MenuItems []string `json:"menuItems"`
	// Enable sound on mouseover previews
	SoundOnPreview *bool `json:"soundOnPreview"`
	// Show title and tags in wall view
	WallShowTitle *bool `json:"wallShowTitle"`
	// Wall playback type
	WallPlayback *string `json:"wallPlayback"`
	// Show scene scrubber by default
	ShowScrubber *bool `json:"showScrubber"`
	// Maximum duration (in seconds) in which a scene video will loop in the scene player
	MaximumLoopDuration *int `json:"maximumLoopDuration"`
	// True if we should not auto-open a browser window on startup
	NoBrowser *bool `json:"noBrowser"`
	// True if we should send desktop notifications
	NotificationsEnabled *bool `json:"notificationsEnabled"`
	// If true, video will autostart on load in the scene player
	AutostartVideo *bool `json:"autostartVideo"`
	// If true, video will autostart when loading from play random or play selected
	AutostartVideoOnPlaySelected *bool `json:"autostartVideoOnPlaySelected"`
	// If true, next scene in playlist will be played at video end by default
	ContinuePlaylistDefault *bool `json:"continuePlaylistDefault"`
	// If true, studio overlays will be shown as text instead of logo images
	ShowStudioAsText *bool `json:"showStudioAsText"`
	// Custom CSS
	CSS        *string `json:"css"`
	CSSEnabled *bool   `json:"cssEnabled"`
	// Interface language
	Language *string `json:"language"`
	// Slideshow Delay
	SlideshowDelay *int                       `json:"slideshowDelay"`
	ImageLightbox  *ConfigImageLightboxResult `json:"imageLightbox"`
	// Fields are true if creating via dropdown menus are disabled
	DisableDropdownCreate  *ConfigDisableDropdownCreate `json:"disableDropdownCreate"`
	DisabledDropdownCreate *ConfigDisableDropdownCreate `json:"disabledDropdownCreate"`
	// Handy Connection Key
	HandyKey *string `json:"handyKey"`
	// Funscript Time Offset
	FunscriptOffset *int `json:"funscriptOffset"`
}

// All configuration settings
type ConfigResult struct {
	General   *ConfigGeneralResult         `json:"general"`
	Interface *ConfigInterfaceResult       `json:"interface"`
	Dlna      *ConfigDLNAResult            `json:"dlna"`
	Scraping  *ConfigScrapingResult        `json:"scraping"`
	Defaults  *ConfigDefaultSettingsResult `json:"defaults"`
	UI        map[string]interface{}       `json:"ui"`
}

type ConfigScrapingInput struct {
	// Scraper user agent string
	ScraperUserAgent *string `json:"scraperUserAgent"`
	// Scraper CDP path. Path to chrome executable or remote address
	ScraperCDPPath *string `json:"scraperCDPPath"`
	// Whether the scraper should check for invalid certificates
	ScraperCertCheck *bool `json:"scraperCertCheck"`
	// Tags blacklist during scraping
	ExcludeTagPatterns []string `json:"excludeTagPatterns"`
}

type ConfigScrapingResult struct {
	// Scraper user agent string
	ScraperUserAgent *string `json:"scraperUserAgent"`
	// Scraper CDP path. Path to chrome executable or remote address
	ScraperCDPPath *string `json:"scraperCDPPath"`
	// Whether the scraper should check for invalid certificates
	ScraperCertCheck bool `json:"scraperCertCheck"`
	// Tags blacklist during scraping
	ExcludeTagPatterns []string `json:"excludeTagPatterns"`
}

type Dlnaip struct {
	IPAddress string `json:"ipAddress"`
	// Time until IP will be no longer allowed/disallowed
	Until *time.Time `json:"until"`
}

type DLNAStatus struct {
	Running bool `json:"running"`
	// If not currently running, time until it will be started. If running, time until it will be stopped
	Until              *time.Time `json:"until"`
	RecentIPAddresses  []string   `json:"recentIPAddresses"`
	AllowedIPAddresses []*Dlnaip  `json:"allowedIPAddresses"`
}

type DestroyFilterInput struct {
	ID string `json:"id"`
}

// Directory structure of a path
type Directory struct {
	Path        string   `json:"path"`
	Parent      *string  `json:"parent"`
	Directories []string `json:"directories"`
}

type DisableDLNAInput struct {
	// Duration to enable, in minutes. 0 or null for indefinite.
	Duration *int `json:"duration"`
}

type EnableDLNAInput struct {
	// Duration to enable, in minutes. 0 or null for indefinite.
	Duration *int `json:"duration"`
}

type ExportObjectTypeInput struct {
	Ids []string `json:"ids"`
	All *bool    `json:"all"`
}

type ExportObjectsInput struct {
	Scenes              *ExportObjectTypeInput `json:"scenes"`
	Images              *ExportObjectTypeInput `json:"images"`
	Studios             *ExportObjectTypeInput `json:"studios"`
	Performers          *ExportObjectTypeInput `json:"performers"`
	Tags                *ExportObjectTypeInput `json:"tags"`
	Movies              *ExportObjectTypeInput `json:"movies"`
	Galleries           *ExportObjectTypeInput `json:"galleries"`
	IncludeDependencies *bool                  `json:"includeDependencies"`
}

type FindFilterType struct {
	Q    *string `json:"q"`
	Page *int    `json:"page"`
	// use per_page = -1 to indicate all results. Defaults to 25.
	PerPage   *int               `json:"per_page"`
	Sort      *string            `json:"sort"`
	Direction *SortDirectionEnum `json:"direction"`
}

type FindGalleriesResultType struct {
	Count     int        `json:"count"`
	Galleries []*Gallery `json:"galleries"`
}

type FindImagesResultType struct {
	Count int `json:"count"`
	// Total megapixels of the images
	Megapixels float64 `json:"megapixels"`
	// Total file size in bytes
	Filesize float64  `json:"filesize"`
	Images   []*Image `json:"images"`
}

type FindJobInput struct {
	ID string `json:"id"`
}

type FindMoviesResultType struct {
	Count  int      `json:"count"`
	Movies []*Movie `json:"movies"`
}

type FindPerformersResultType struct {
	Count      int          `json:"count"`
	Performers []*Performer `json:"performers"`
}

type FindSceneMarkersResultType struct {
	Count        int            `json:"count"`
	SceneMarkers []*SceneMarker `json:"scene_markers"`
}

type FindScenesResultType struct {
	Count int `json:"count"`
	// Total duration in seconds
	Duration float64 `json:"duration"`
	// Total file size in bytes
	Filesize float64  `json:"filesize"`
	Scenes   []*Scene `json:"scenes"`
}

type FindStudiosResultType struct {
	Count   int       `json:"count"`
	Studios []*Studio `json:"studios"`
}

type FindTagsResultType struct {
	Count int    `json:"count"`
	Tags  []*Tag `json:"tags"`
}

type GalleryAddInput struct {
	GalleryID string   `json:"gallery_id"`
	ImageIds  []string `json:"image_ids"`
}

type GalleryCreateInput struct {
	Title        string   `json:"title"`
	URL          *string  `json:"url"`
	Date         *string  `json:"date"`
	Details      *string  `json:"details"`
	Rating       *int     `json:"rating"`
	Organized    *bool    `json:"organized"`
	SceneIds     []string `json:"scene_ids"`
	StudioID     *string  `json:"studio_id"`
	TagIds       []string `json:"tag_ids"`
	PerformerIds []string `json:"performer_ids"`
}

type GalleryDestroyInput struct {
	Ids []string `json:"ids"`
	// If true, then the zip file will be deleted if the gallery is zip-file-based.
	// If gallery is folder-based, then any files not associated with other
	// galleries will be deleted, along with the folder, if it is not empty.
	DeleteFile      *bool `json:"delete_file"`
	DeleteGenerated *bool `json:"delete_generated"`
}

type GalleryFilesType struct {
	Index int     `json:"index"`
	Name  *string `json:"name"`
	Path  *string `json:"path"`
}

type GalleryFilterType struct {
	And     *GalleryFilterType    `json:"AND"`
	Or      *GalleryFilterType    `json:"OR"`
	Not     *GalleryFilterType    `json:"NOT"`
	Title   *StringCriterionInput `json:"title"`
	Details *StringCriterionInput `json:"details"`
	// Filter by file checksum
	Checksum *StringCriterionInput `json:"checksum"`
	// Filter by path
	Path *StringCriterionInput `json:"path"`
	// Filter to only include galleries missing this property
	IsMissing *string `json:"is_missing"`
	// Filter to include/exclude galleries that were created from zip
	IsZip *bool `json:"is_zip"`
	// Filter by rating
	Rating *IntCriterionInput `json:"rating"`
	// Filter by organized
	Organized *bool `json:"organized"`
	// Filter by average image resolution
	AverageResolution *ResolutionCriterionInput `json:"average_resolution"`
	// Filter to only include galleries with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios"`
	// Filter to only include galleries with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count"`
	// Filter to only include galleries with performers with these tags
	PerformerTags *HierarchicalMultiCriterionInput `json:"performer_tags"`
	// Filter to only include galleries with these performers
	Performers *MultiCriterionInput `json:"performers"`
	// Filter by performer count
	PerformerCount *IntCriterionInput `json:"performer_count"`
	// Filter galleries that have performers that have been favorited
	PerformerFavorite *bool `json:"performer_favorite"`
	// Filter galleries by performer age at time of gallery
	PerformerAge *IntCriterionInput `json:"performer_age"`
	// Filter by number of images in this gallery
	ImageCount *IntCriterionInput `json:"image_count"`
	// Filter by url
	URL *StringCriterionInput `json:"url"`
}

type GalleryRemoveInput struct {
	GalleryID string   `json:"gallery_id"`
	ImageIds  []string `json:"image_ids"`
}

type GalleryUpdateInput struct {
	ClientMutationID *string  `json:"clientMutationId"`
	ID               string   `json:"id"`
	Title            *string  `json:"title"`
	URL              *string  `json:"url"`
	Date             *string  `json:"date"`
	Details          *string  `json:"details"`
	Rating           *int     `json:"rating"`
	Organized        *bool    `json:"organized"`
	SceneIds         []string `json:"scene_ids"`
	StudioID         *string  `json:"studio_id"`
	TagIds           []string `json:"tag_ids"`
	PerformerIds     []string `json:"performer_ids"`
}

type GenderCriterionInput struct {
	Value    *GenderEnum       `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type GenerateAPIKeyInput struct {
	Clear *bool `json:"clear"`
}

type GenerateMetadataInput struct {
	Sprites             *bool                        `json:"sprites"`
	Previews            *bool                        `json:"previews"`
	ImagePreviews       *bool                        `json:"imagePreviews"`
	PreviewOptions      *GeneratePreviewOptionsInput `json:"previewOptions"`
	Markers             *bool                        `json:"markers"`
	MarkerImagePreviews *bool                        `json:"markerImagePreviews"`
	MarkerScreenshots   *bool                        `json:"markerScreenshots"`
	Transcodes          *bool                        `json:"transcodes"`
	// Generate transcodes even if not required
	ForceTranscodes           *bool `json:"forceTranscodes"`
	Phashes                   *bool `json:"phashes"`
	InteractiveHeatmapsSpeeds *bool `json:"interactiveHeatmapsSpeeds"`
	// scene ids to generate for
	SceneIDs []string `json:"sceneIDs"`
	// marker ids to generate for
	MarkerIDs []string `json:"markerIDs"`
	// overwrite existing media
	Overwrite *bool `json:"overwrite"`
}

type GenerateMetadataOptions struct {
	Sprites                   *bool                   `json:"sprites"`
	Previews                  *bool                   `json:"previews"`
	ImagePreviews             *bool                   `json:"imagePreviews"`
	PreviewOptions            *GeneratePreviewOptions `json:"previewOptions"`
	Markers                   *bool                   `json:"markers"`
	MarkerImagePreviews       *bool                   `json:"markerImagePreviews"`
	MarkerScreenshots         *bool                   `json:"markerScreenshots"`
	Transcodes                *bool                   `json:"transcodes"`
	Phashes                   *bool                   `json:"phashes"`
	InteractiveHeatmapsSpeeds *bool                   `json:"interactiveHeatmapsSpeeds"`
}

type GeneratePreviewOptions struct {
	// Number of segments in a preview file
	PreviewSegments *int `json:"previewSegments"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration *float64 `json:"previewSegmentDuration"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart *string `json:"previewExcludeStart"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd *string `json:"previewExcludeEnd"`
	// Preset when generating preview
	PreviewPreset *PreviewPreset `json:"previewPreset"`
}

type GeneratePreviewOptionsInput struct {
	// Number of segments in a preview file
	PreviewSegments *int `json:"previewSegments"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration *float64 `json:"previewSegmentDuration"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart *string `json:"previewExcludeStart"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd *string `json:"previewExcludeEnd"`
	// Preset when generating preview
	PreviewPreset *PreviewPreset `json:"previewPreset"`
}

type HierarchicalMultiCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
	Depth    *int              `json:"depth"`
}

type IdentifyFieldOptions struct {
	Field    string                `json:"field"`
	Strategy IdentifyFieldStrategy `json:"strategy"`
	// creates missing objects if needed - only applicable for performers, tags and studios
	CreateMissing *bool `json:"createMissing"`
}

type IdentifyFieldOptionsInput struct {
	Field    string                `json:"field"`
	Strategy IdentifyFieldStrategy `json:"strategy"`
	// creates missing objects if needed - only applicable for performers, tags and studios
	CreateMissing *bool `json:"createMissing"`
}

type IdentifyMetadataInput struct {
	// An ordered list of sources to identify items with. Only the first source that finds a match is used.
	Sources []*IdentifySourceInput `json:"sources"`
	// Options defined here override the configured defaults
	Options *IdentifyMetadataOptionsInput `json:"options"`
	// scene ids to identify
	SceneIDs []string `json:"sceneIDs"`
	// paths of scenes to identify - ignored if scene ids are set
	Paths []string `json:"paths"`
}

type IdentifyMetadataOptions struct {
	// any fields missing from here are defaulted to MERGE and createMissing false
	FieldOptions []*IdentifyFieldOptions `json:"fieldOptions"`
	// defaults to true if not provided
	SetCoverImage *bool `json:"setCoverImage"`
	SetOrganized  *bool `json:"setOrganized"`
	// defaults to true if not provided
	IncludeMalePerformers *bool `json:"includeMalePerformers"`
}

type IdentifyMetadataOptionsInput struct {
	// any fields missing from here are defaulted to MERGE and createMissing false
	FieldOptions []*IdentifyFieldOptionsInput `json:"fieldOptions"`
	// defaults to true if not provided
	SetCoverImage *bool `json:"setCoverImage"`
	SetOrganized  *bool `json:"setOrganized"`
	// defaults to true if not provided
	IncludeMalePerformers *bool `json:"includeMalePerformers"`
}

type IdentifyMetadataTaskOptions struct {
	// An ordered list of sources to identify items with. Only the first source that finds a match is used.
	Sources []*IdentifySource `json:"sources"`
	// Options defined here override the configured defaults
	Options *IdentifyMetadataOptions `json:"options"`
}

type IdentifySource struct {
	Source *ScraperSource `json:"source"`
	// Options defined for a source override the defaults
	Options *IdentifyMetadataOptions `json:"options"`
}

type IdentifySourceInput struct {
	Source *ScraperSourceInput `json:"source"`
	// Options defined for a source override the defaults
	Options *IdentifyMetadataOptionsInput `json:"options"`
}

type ImageDestroyInput struct {
	ID              string `json:"id"`
	DeleteFile      *bool  `json:"delete_file"`
	DeleteGenerated *bool  `json:"delete_generated"`
}

type ImageFilterType struct {
	And   *ImageFilterType      `json:"AND"`
	Or    *ImageFilterType      `json:"OR"`
	Not   *ImageFilterType      `json:"NOT"`
	Title *StringCriterionInput `json:"title"`
	// Filter by file checksum
	Checksum *StringCriterionInput `json:"checksum"`
	// Filter by path
	Path *StringCriterionInput `json:"path"`
	// Filter by rating
	Rating *IntCriterionInput `json:"rating"`
	// Filter by organized
	Organized *bool `json:"organized"`
	// Filter by o-counter
	OCounter *IntCriterionInput `json:"o_counter"`
	// Filter by resolution
	Resolution *ResolutionCriterionInput `json:"resolution"`
	// Filter to only include images missing this property
	IsMissing *string `json:"is_missing"`
	// Filter to only include images with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios"`
	// Filter to only include images with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count"`
	// Filter to only include images with performers with these tags
	PerformerTags *HierarchicalMultiCriterionInput `json:"performer_tags"`
	// Filter to only include images with these performers
	Performers *MultiCriterionInput `json:"performers"`
	// Filter by performer count
	PerformerCount *IntCriterionInput `json:"performer_count"`
	// Filter images that have performers that have been favorited
	PerformerFavorite *bool `json:"performer_favorite"`
	// Filter to only include images with these galleries
	Galleries *MultiCriterionInput `json:"galleries"`
}

type ImagePathsType struct {
	Thumbnail *string `json:"thumbnail"`
	Image     *string `json:"image"`
}

type ImageUpdateInput struct {
	ClientMutationID *string  `json:"clientMutationId"`
	ID               string   `json:"id"`
	Title            *string  `json:"title"`
	Rating           *int     `json:"rating"`
	Organized        *bool    `json:"organized"`
	StudioID         *string  `json:"studio_id"`
	PerformerIds     []string `json:"performer_ids"`
	TagIds           []string `json:"tag_ids"`
	GalleryIds       []string `json:"gallery_ids"`
}

type ImagesDestroyInput struct {
	Ids             []string `json:"ids"`
	DeleteFile      *bool    `json:"delete_file"`
	DeleteGenerated *bool    `json:"delete_generated"`
}

type ImportObjectsInput struct {
	File                graphql.Upload       `json:"file"`
	DuplicateBehaviour  ImportDuplicateEnum  `json:"duplicateBehaviour"`
	MissingRefBehaviour ImportMissingRefEnum `json:"missingRefBehaviour"`
}

type IntCriterionInput struct {
	Value    int               `json:"value"`
	Value2   *int              `json:"value2"`
	Modifier CriterionModifier `json:"modifier"`
}

type Job struct {
	ID          string     `json:"id"`
	Status      JobStatus  `json:"status"`
	SubTasks    []string   `json:"subTasks"`
	Description string     `json:"description"`
	Progress    *float64   `json:"progress"`
	StartTime   *time.Time `json:"startTime"`
	EndTime     *time.Time `json:"endTime"`
	AddTime     time.Time  `json:"addTime"`
}

type JobStatusUpdate struct {
	Type JobStatusUpdateType `json:"type"`
	Job  *Job                `json:"job"`
}

type LogEntry struct {
	Time    time.Time `json:"time"`
	Level   LogLevel  `json:"level"`
	Message string    `json:"message"`
}

type MarkerStringsResultType struct {
	Count int    `json:"count"`
	ID    string `json:"id"`
	Title string `json:"title"`
}

type MigrateInput struct {
	BackupPath string `json:"backupPath"`
}

type MovieCreateInput struct {
	Name    string  `json:"name"`
	Aliases *string `json:"aliases"`
	// Duration in seconds
	Duration *int    `json:"duration"`
	Date     *string `json:"date"`
	Rating   *int    `json:"rating"`
	StudioID *string `json:"studio_id"`
	Director *string `json:"director"`
	Synopsis *string `json:"synopsis"`
	URL      *string `json:"url"`
	// This should be a URL or a base64 encoded data URL
	FrontImage *string `json:"front_image"`
	// This should be a URL or a base64 encoded data URL
	BackImage *string `json:"back_image"`
}

type MovieDestroyInput struct {
	ID string `json:"id"`
}

type MovieFilterType struct {
	Name     *StringCriterionInput `json:"name"`
	Director *StringCriterionInput `json:"director"`
	Synopsis *StringCriterionInput `json:"synopsis"`
	// Filter by duration (in seconds)
	Duration *IntCriterionInput `json:"duration"`
	// Filter by rating
	Rating *IntCriterionInput `json:"rating"`
	// Filter to only include movies with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios"`
	// Filter to only include movies missing this property
	IsMissing *string `json:"is_missing"`
	// Filter by url
	URL *StringCriterionInput `json:"url"`
	// Filter to only include movies where performer appears in a scene
	Performers *MultiCriterionInput `json:"performers"`
}

type MovieUpdateInput struct {
	ID       string  `json:"id"`
	Name     *string `json:"name"`
	Aliases  *string `json:"aliases"`
	Duration *int    `json:"duration"`
	Date     *string `json:"date"`
	Rating   *int    `json:"rating"`
	StudioID *string `json:"studio_id"`
	Director *string `json:"director"`
	Synopsis *string `json:"synopsis"`
	URL      *string `json:"url"`
	// This should be a URL or a base64 encoded data URL
	FrontImage *string `json:"front_image"`
	// This should be a URL or a base64 encoded data URL
	BackImage *string `json:"back_image"`
}

type MultiCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type PHashDuplicationCriterionInput struct {
	Duplicated *bool `json:"duplicated"`
	// Currently unimplemented
	Distance *int `json:"distance"`
}

type PerformerCreateInput struct {
	Name         string      `json:"name"`
	URL          *string     `json:"url"`
	Gender       *GenderEnum `json:"gender"`
	Birthdate    *string     `json:"birthdate"`
	Ethnicity    *string     `json:"ethnicity"`
	Country      *string     `json:"country"`
	EyeColor     *string     `json:"eye_color"`
	Height       *string     `json:"height"`
	Measurements *string     `json:"measurements"`
	FakeTits     *string     `json:"fake_tits"`
	CareerLength *string     `json:"career_length"`
	Tattoos      *string     `json:"tattoos"`
	Piercings    *string     `json:"piercings"`
	Aliases      *string     `json:"aliases"`
	Twitter      *string     `json:"twitter"`
	Instagram    *string     `json:"instagram"`
	Favorite     *bool       `json:"favorite"`
	TagIds       []string    `json:"tag_ids"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image"`
	StashIds      []*StashIDInput `json:"stash_ids"`
	Rating        *int            `json:"rating"`
	Details       *string         `json:"details"`
	DeathDate     *string         `json:"death_date"`
	HairColor     *string         `json:"hair_color"`
	Weight        *int            `json:"weight"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag"`
}

type PerformerDestroyInput struct {
	ID string `json:"id"`
}

type PerformerFilterType struct {
	And     *PerformerFilterType  `json:"AND"`
	Or      *PerformerFilterType  `json:"OR"`
	Not     *PerformerFilterType  `json:"NOT"`
	Name    *StringCriterionInput `json:"name"`
	Details *StringCriterionInput `json:"details"`
	// Filter by favorite
	FilterFavorites *bool `json:"filter_favorites"`
	// Filter by birth year
	BirthYear *IntCriterionInput `json:"birth_year"`
	// Filter by age
	Age *IntCriterionInput `json:"age"`
	// Filter by ethnicity
	Ethnicity *StringCriterionInput `json:"ethnicity"`
	// Filter by country
	Country *StringCriterionInput `json:"country"`
	// Filter by eye color
	EyeColor *StringCriterionInput `json:"eye_color"`
	// Filter by height
	Height *StringCriterionInput `json:"height"`
	// Filter by measurements
	Measurements *StringCriterionInput `json:"measurements"`
	// Filter by fake tits value
	FakeTits *StringCriterionInput `json:"fake_tits"`
	// Filter by career length
	CareerLength *StringCriterionInput `json:"career_length"`
	// Filter by tattoos
	Tattoos *StringCriterionInput `json:"tattoos"`
	// Filter by piercings
	Piercings *StringCriterionInput `json:"piercings"`
	// Filter by aliases
	Aliases *StringCriterionInput `json:"aliases"`
	// Filter by gender
	Gender *GenderCriterionInput `json:"gender"`
	// Filter to only include performers missing this property
	IsMissing *string `json:"is_missing"`
	// Filter to only include performers with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count"`
	// Filter by scene count
	SceneCount *IntCriterionInput `json:"scene_count"`
	// Filter by image count
	ImageCount *IntCriterionInput `json:"image_count"`
	// Filter by gallery count
	GalleryCount *IntCriterionInput `json:"gallery_count"`
	// Filter by StashID
	StashID *StringCriterionInput `json:"stash_id"`
	// Filter by rating
	Rating *IntCriterionInput `json:"rating"`
	// Filter by url
	URL *StringCriterionInput `json:"url"`
	// Filter by hair color
	HairColor *StringCriterionInput `json:"hair_color"`
	// Filter by weight
	Weight *IntCriterionInput `json:"weight"`
	// Filter by death year
	DeathYear *IntCriterionInput `json:"death_year"`
	// Filter by studios where performer appears in scene/image/gallery
	Studios *HierarchicalMultiCriterionInput `json:"studios"`
	// Filter by autotag ignore value
	IgnoreAutoTag *bool `json:"ignore_auto_tag"`
}

type PerformerUpdateInput struct {
	ID           string      `json:"id"`
	Name         *string     `json:"name"`
	URL          *string     `json:"url"`
	Gender       *GenderEnum `json:"gender"`
	Birthdate    *string     `json:"birthdate"`
	Ethnicity    *string     `json:"ethnicity"`
	Country      *string     `json:"country"`
	EyeColor     *string     `json:"eye_color"`
	Height       *string     `json:"height"`
	Measurements *string     `json:"measurements"`
	FakeTits     *string     `json:"fake_tits"`
	CareerLength *string     `json:"career_length"`
	Tattoos      *string     `json:"tattoos"`
	Piercings    *string     `json:"piercings"`
	Aliases      *string     `json:"aliases"`
	Twitter      *string     `json:"twitter"`
	Instagram    *string     `json:"instagram"`
	Favorite     *bool       `json:"favorite"`
	TagIds       []string    `json:"tag_ids"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image"`
	StashIds      []*StashIDInput `json:"stash_ids"`
	Rating        *int            `json:"rating"`
	Details       *string         `json:"details"`
	DeathDate     *string         `json:"death_date"`
	HairColor     *string         `json:"hair_color"`
	Weight        *int            `json:"weight"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag"`
}

type Plugin struct {
	ID          string        `json:"id"`
	Name        string        `json:"name"`
	Description *string       `json:"description"`
	URL         *string       `json:"url"`
	Version     *string       `json:"version"`
	Tasks       []*PluginTask `json:"tasks"`
	Hooks       []*PluginHook `json:"hooks"`
}

type PluginArgInput struct {
	Key   string            `json:"key"`
	Value *PluginValueInput `json:"value"`
}

type PluginHook struct {
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Hooks       []string `json:"hooks"`
	Plugin      *Plugin  `json:"plugin"`
}

type PluginResult struct {
	Error  *string `json:"error"`
	Result *string `json:"result"`
}

type PluginTask struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Plugin      *Plugin `json:"plugin"`
}

type PluginValueInput struct {
	Str *string             `json:"str"`
	I   *int                `json:"i"`
	B   *bool               `json:"b"`
	F   *float64            `json:"f"`
	O   []*PluginArgInput   `json:"o"`
	A   []*PluginValueInput `json:"a"`
}

type RemoveTempDLNAIPInput struct {
	Address string `json:"address"`
}

type ResolutionCriterionInput struct {
	Value    ResolutionEnum    `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type SaveFilterInput struct {
	// provide ID to overwrite existing filter
	ID   *string    `json:"id"`
	Mode FilterMode `json:"mode"`
	Name string     `json:"name"`
	// JSON-encoded filter string
	Filter string `json:"filter"`
}

// Filter options for meta data scannning
type ScanMetaDataFilterInput struct {
	// If set, files with a modification time before this time point are ignored by the scan
	MinModTime *time.Time `json:"minModTime"`
}

type ScanMetadataInput struct {
	Paths []string `json:"paths"`
	// Set name, date, details from metadata (if present)
	UseFileMetadata *bool `json:"useFileMetadata"`
	// Strip file extension from title
	StripFileExtension *bool `json:"stripFileExtension"`
	// Generate previews during scan
	ScanGeneratePreviews *bool `json:"scanGeneratePreviews"`
	// Generate image previews during scan
	ScanGenerateImagePreviews *bool `json:"scanGenerateImagePreviews"`
	// Generate sprites during scan
	ScanGenerateSprites *bool `json:"scanGenerateSprites"`
	// Generate phashes during scan
	ScanGeneratePhashes *bool `json:"scanGeneratePhashes"`
	// Generate image thumbnails during scan
	ScanGenerateThumbnails *bool `json:"scanGenerateThumbnails"`
	// Filter options for the scan
	Filter *ScanMetaDataFilterInput `json:"filter"`
}

type ScanMetadataOptions struct {
	// Set name, date, details from metadata (if present)
	UseFileMetadata bool `json:"useFileMetadata"`
	// Strip file extension from title
	StripFileExtension bool `json:"stripFileExtension"`
	// Generate previews during scan
	ScanGeneratePreviews bool `json:"scanGeneratePreviews"`
	// Generate image previews during scan
	ScanGenerateImagePreviews bool `json:"scanGenerateImagePreviews"`
	// Generate sprites during scan
	ScanGenerateSprites bool `json:"scanGenerateSprites"`
	// Generate phashes during scan
	ScanGeneratePhashes bool `json:"scanGeneratePhashes"`
	// Generate image thumbnails during scan
	ScanGenerateThumbnails bool `json:"scanGenerateThumbnails"`
}

type SceneDestroyInput struct {
	ID              string `json:"id"`
	DeleteFile      *bool  `json:"delete_file"`
	DeleteGenerated *bool  `json:"delete_generated"`
}

type SceneFilterType struct {
	And     *SceneFilterType      `json:"AND"`
	Or      *SceneFilterType      `json:"OR"`
	Not     *SceneFilterType      `json:"NOT"`
	Title   *StringCriterionInput `json:"title"`
	Details *StringCriterionInput `json:"details"`
	// Filter by file oshash
	Oshash *StringCriterionInput `json:"oshash"`
	// Filter by file checksum
	Checksum *StringCriterionInput `json:"checksum"`
	// Filter by file phash
	Phash *StringCriterionInput `json:"phash"`
	// Filter by path
	Path *StringCriterionInput `json:"path"`
	// Filter by rating
	Rating *IntCriterionInput `json:"rating"`
	// Filter by organized
	Organized *bool `json:"organized"`
	// Filter by o-counter
	OCounter *IntCriterionInput `json:"o_counter"`
	// Filter Scenes that have an exact phash match available
	Duplicated *PHashDuplicationCriterionInput `json:"duplicated"`
	// Filter by resolution
	Resolution *ResolutionCriterionInput `json:"resolution"`
	// Filter by duration (in seconds)
	Duration *IntCriterionInput `json:"duration"`
	// Filter to only include scenes which have markers. `true` or `false`
	HasMarkers *string `json:"has_markers"`
	// Filter to only include scenes missing this property
	IsMissing *string `json:"is_missing"`
	// Filter to only include scenes with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios"`
	// Filter to only include scenes with this movie
	Movies *MultiCriterionInput `json:"movies"`
	// Filter to only include scenes with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count"`
	// Filter to only include scenes with performers with these tags
	PerformerTags *HierarchicalMultiCriterionInput `json:"performer_tags"`
	// Filter scenes that have performers that have been favorited
	PerformerFavorite *bool `json:"performer_favorite"`
	// Filter scenes by performer age at time of scene
	PerformerAge *IntCriterionInput `json:"performer_age"`
	// Filter to only include scenes with these performers
	Performers *MultiCriterionInput `json:"performers"`
	// Filter by performer count
	PerformerCount *IntCriterionInput `json:"performer_count"`
	// Filter by StashID
	StashID *StringCriterionInput `json:"stash_id"`
	// Filter by url
	URL *StringCriterionInput `json:"url"`
	// Filter by interactive
	Interactive *bool `json:"interactive"`
	// Filter by InteractiveSpeed
	InteractiveSpeed *IntCriterionInput `json:"interactive_speed"`
	// Filter by captions
	Captions *StringCriterionInput `json:"captions"`
}

type SceneHashInput struct {
	Checksum *string `json:"checksum"`
	Oshash   *string `json:"oshash"`
}

type SceneMarkerCreateInput struct {
	Title        string   `json:"title"`
	Seconds      float64  `json:"seconds"`
	SceneID      string   `json:"scene_id"`
	PrimaryTagID string   `json:"primary_tag_id"`
	TagIds       []string `json:"tag_ids"`
}

type SceneMarkerFilterType struct {
	// Filter to only include scene markers with this tag
	TagID *string `json:"tag_id"`
	// Filter to only include scene markers with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags"`
	// Filter to only include scene markers attached to a scene with these tags
	SceneTags *HierarchicalMultiCriterionInput `json:"scene_tags"`
	// Filter to only include scene markers with these performers
	Performers *MultiCriterionInput `json:"performers"`
}

type SceneMarkerTag struct {
	Tag          *Tag           `json:"tag"`
	SceneMarkers []*SceneMarker `json:"scene_markers"`
}

type SceneMarkerUpdateInput struct {
	ID           string   `json:"id"`
	Title        string   `json:"title"`
	Seconds      float64  `json:"seconds"`
	SceneID      string   `json:"scene_id"`
	PrimaryTagID string   `json:"primary_tag_id"`
	TagIds       []string `json:"tag_ids"`
}

type SceneMovie struct {
	Movie      *Movie `json:"movie"`
	SceneIndex *int   `json:"scene_index"`
}

type SceneMovieID struct {
	MovieID    string  `json:"movie_id"`
	SceneIndex *string `json:"scene_index"`
}

type SceneMovieInput struct {
	MovieID    string `json:"movie_id"`
	SceneIndex *int   `json:"scene_index"`
}

type SceneParserInput struct {
	IgnoreWords          []string `json:"ignoreWords"`
	WhitespaceCharacters *string  `json:"whitespaceCharacters"`
	CapitalizeTitle      *bool    `json:"capitalizeTitle"`
	IgnoreOrganized      *bool    `json:"ignoreOrganized"`
}

type SceneParserResult struct {
	Scene        *Scene          `json:"scene"`
	Title        *string         `json:"title"`
	Details      *string         `json:"details"`
	URL          *string         `json:"url"`
	Date         *string         `json:"date"`
	Rating       *int            `json:"rating"`
	StudioID     *string         `json:"studio_id"`
	GalleryIds   []string        `json:"gallery_ids"`
	PerformerIds []string        `json:"performer_ids"`
	Movies       []*SceneMovieID `json:"movies"`
	TagIds       []string        `json:"tag_ids"`
}

type SceneParserResultType struct {
	Count   int                  `json:"count"`
	Results []*SceneParserResult `json:"results"`
}

type ScenePathsType struct {
	Screenshot         *string `json:"screenshot"`
	Preview            *string `json:"preview"`
	Stream             *string `json:"stream"`
	Webp               *string `json:"webp"`
	Vtt                *string `json:"vtt"`
	ChaptersVtt        *string `json:"chapters_vtt"`
	Sprite             *string `json:"sprite"`
	Funscript          *string `json:"funscript"`
	InteractiveHeatmap *string `json:"interactive_heatmap"`
	Caption            *string `json:"caption"`
}

type SceneStreamEndpoint struct {
	URL      string  `json:"url"`
	MimeType *string `json:"mime_type"`
	Label    *string `json:"label"`
}

type SceneUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId"`
	ID               string             `json:"id"`
	Title            *string            `json:"title"`
	Details          *string            `json:"details"`
	URL              *string            `json:"url"`
	Date             *string            `json:"date"`
	Rating           *int               `json:"rating"`
	Organized        *bool              `json:"organized"`
	StudioID         *string            `json:"studio_id"`
	GalleryIds       []string           `json:"gallery_ids"`
	PerformerIds     []string           `json:"performer_ids"`
	Movies           []*SceneMovieInput `json:"movies"`
	TagIds           []string           `json:"tag_ids"`
	// This should be a URL or a base64 encoded data URL
	CoverImage *string         `json:"cover_image"`
	StashIds   []*StashIDInput `json:"stash_ids"`
}

type ScenesDestroyInput struct {
	Ids             []string `json:"ids"`
	DeleteFile      *bool    `json:"delete_file"`
	DeleteGenerated *bool    `json:"delete_generated"`
}

type ScrapeMultiPerformersInput struct {
	// Instructs to query by scene fingerprints
	PerformerIds []string `json:"performer_ids"`
}

type ScrapeMultiScenesInput struct {
	// Instructs to query by scene fingerprints
	SceneIds []string `json:"scene_ids"`
}

type ScrapeSingleGalleryInput struct {
	// Instructs to query by string
	Query *string `json:"query"`
	// Instructs to query by gallery id
	GalleryID *string `json:"gallery_id"`
	// Instructs to query by gallery fragment
	GalleryInput *ScrapedGalleryInput `json:"gallery_input"`
}

type ScrapeSingleMovieInput struct {
	// Instructs to query by string
	Query *string `json:"query"`
	// Instructs to query by movie id
	MovieID *string `json:"movie_id"`
	// Instructs to query by gallery fragment
	MovieInput *ScrapedMovieInput `json:"movie_input"`
}

type ScrapeSinglePerformerInput struct {
	// Instructs to query by string
	Query *string `json:"query"`
	// Instructs to query by performer id
	PerformerID *string `json:"performer_id"`
	// Instructs to query by performer fragment
	PerformerInput *ScrapedPerformerInput `json:"performer_input"`
}

type ScrapeSingleSceneInput struct {
	// Instructs to query by string
	Query *string `json:"query"`
	// Instructs to query by scene fingerprints
	SceneID *string `json:"scene_id"`
	// Instructs to query by scene fragment
	SceneInput *ScrapedSceneInput `json:"scene_input"`
}

type ScrapedGallery struct {
	Title      *string             `json:"title"`
	Details    *string             `json:"details"`
	URL        *string             `json:"url"`
	Date       *string             `json:"date"`
	Studio     *ScrapedStudio      `json:"studio"`
	Tags       []*ScrapedTag       `json:"tags"`
	Performers []*ScrapedPerformer `json:"performers"`
}

func (ScrapedGallery) IsScrapedContent() {}

type ScrapedGalleryInput struct {
	Title   *string `json:"title"`
	Details *string `json:"details"`
	URL     *string `json:"url"`
	Date    *string `json:"date"`
}

// A movie from a scraping operation...
type ScrapedMovie struct {
	StoredID *string        `json:"stored_id"`
	Name     *string        `json:"name"`
	Aliases  *string        `json:"aliases"`
	Duration *string        `json:"duration"`
	Date     *string        `json:"date"`
	Rating   *string        `json:"rating"`
	Director *string        `json:"director"`
	URL      *string        `json:"url"`
	Synopsis *string        `json:"synopsis"`
	Studio   *ScrapedStudio `json:"studio"`
	// This should be a base64 encoded data URL
	FrontImage *string `json:"front_image"`
	// This should be a base64 encoded data URL
	BackImage *string `json:"back_image"`
}

func (ScrapedMovie) IsScrapedContent() {}

type ScrapedMovieInput struct {
	Name     *string `json:"name"`
	Aliases  *string `json:"aliases"`
	Duration *string `json:"duration"`
	Date     *string `json:"date"`
	Rating   *string `json:"rating"`
	Director *string `json:"director"`
	URL      *string `json:"url"`
	Synopsis *string `json:"synopsis"`
}

// A performer from a scraping operation...
type ScrapedPerformer struct {
	// Set if performer matched
	StoredID     *string       `json:"stored_id"`
	Name         *string       `json:"name"`
	Gender       *string       `json:"gender"`
	URL          *string       `json:"url"`
	Twitter      *string       `json:"twitter"`
	Instagram    *string       `json:"instagram"`
	Birthdate    *string       `json:"birthdate"`
	Ethnicity    *string       `json:"ethnicity"`
	Country      *string       `json:"country"`
	EyeColor     *string       `json:"eye_color"`
	Height       *string       `json:"height"`
	Measurements *string       `json:"measurements"`
	FakeTits     *string       `json:"fake_tits"`
	CareerLength *string       `json:"career_length"`
	Tattoos      *string       `json:"tattoos"`
	Piercings    *string       `json:"piercings"`
	Aliases      *string       `json:"aliases"`
	Tags         []*ScrapedTag `json:"tags"`
	// This should be a base64 encoded data URL
	Image        *string  `json:"image"`
	Images       []string `json:"images"`
	Details      *string  `json:"details"`
	DeathDate    *string  `json:"death_date"`
	HairColor    *string  `json:"hair_color"`
	Weight       *string  `json:"weight"`
	RemoteSiteID *string  `json:"remote_site_id"`
}

func (ScrapedPerformer) IsScrapedContent() {}

type ScrapedPerformerInput struct {
	// Set if performer matched
	StoredID     *string `json:"stored_id"`
	Name         *string `json:"name"`
	Gender       *string `json:"gender"`
	URL          *string `json:"url"`
	Twitter      *string `json:"twitter"`
	Instagram    *string `json:"instagram"`
	Birthdate    *string `json:"birthdate"`
	Ethnicity    *string `json:"ethnicity"`
	Country      *string `json:"country"`
	EyeColor     *string `json:"eye_color"`
	Height       *string `json:"height"`
	Measurements *string `json:"measurements"`
	FakeTits     *string `json:"fake_tits"`
	CareerLength *string `json:"career_length"`
	Tattoos      *string `json:"tattoos"`
	Piercings    *string `json:"piercings"`
	Aliases      *string `json:"aliases"`
	Details      *string `json:"details"`
	DeathDate    *string `json:"death_date"`
	HairColor    *string `json:"hair_color"`
	Weight       *string `json:"weight"`
	RemoteSiteID *string `json:"remote_site_id"`
}

type ScrapedScene struct {
	Title   *string `json:"title"`
	Details *string `json:"details"`
	URL     *string `json:"url"`
	Date    *string `json:"date"`
	// This should be a base64 encoded data URL
	Image        *string                `json:"image"`
	File         *SceneFileType         `json:"file"`
	Studio       *ScrapedStudio         `json:"studio"`
	Tags         []*ScrapedTag          `json:"tags"`
	Performers   []*ScrapedPerformer    `json:"performers"`
	Movies       []*ScrapedMovie        `json:"movies"`
	RemoteSiteID *string                `json:"remote_site_id"`
	Duration     *int                   `json:"duration"`
	Fingerprints []*StashBoxFingerprint `json:"fingerprints"`
}

func (ScrapedScene) IsScrapedContent() {}

type ScrapedSceneInput struct {
	Title        *string `json:"title"`
	Details      *string `json:"details"`
	URL          *string `json:"url"`
	Date         *string `json:"date"`
	RemoteSiteID *string `json:"remote_site_id"`
}

type ScrapedStudio struct {
	// Set if studio matched
	StoredID     *string `json:"stored_id"`
	Name         string  `json:"name"`
	URL          *string `json:"url"`
	Image        *string `json:"image"`
	RemoteSiteID *string `json:"remote_site_id"`
}

func (ScrapedStudio) IsScrapedContent() {}

type ScrapedTag struct {
	// Set if tag matched
	StoredID *string `json:"stored_id"`
	Name     string  `json:"name"`
}

func (ScrapedTag) IsScrapedContent() {}

type Scraper struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// Details for performer scraper
	Performer *ScraperSpec `json:"performer"`
	// Details for scene scraper
	Scene *ScraperSpec `json:"scene"`
	// Details for gallery scraper
	Gallery *ScraperSpec `json:"gallery"`
	// Details for movie scraper
	Movie *ScraperSpec `json:"movie"`
}

type ScraperSource struct {
	// Index of the configured stash-box instance to use. Should be unset if scraper_id is set
	StashBoxIndex *int `json:"stash_box_index"`
	// Stash-box endpoint
	StashBoxEndpoint *string `json:"stash_box_endpoint"`
	// Scraper ID to scrape with. Should be unset if stash_box_index is set
	ScraperID *string `json:"scraper_id"`
}

type ScraperSourceInput struct {
	// Index of the configured stash-box instance to use. Should be unset if scraper_id is set
	StashBoxIndex *int `json:"stash_box_index"`
	// Stash-box endpoint
	StashBoxEndpoint *string `json:"stash_box_endpoint"`
	// Scraper ID to scrape with. Should be unset if stash_box_index is set
	ScraperID *string `json:"scraper_id"`
}

type ScraperSpec struct {
	// URLs matching these can be scraped with
	Urls             []string     `json:"urls"`
	SupportedScrapes []ScrapeType `json:"supported_scrapes"`
}

type SetDefaultFilterInput struct {
	Mode FilterMode `json:"mode"`
	// JSON-encoded filter string - null to clear
	Filter *string `json:"filter"`
}

type SetupInput struct {
	// Empty to indicate $HOME/.stash/config.yml default
	ConfigLocation string              `json:"configLocation"`
	Stashes        []*StashConfigInput `json:"stashes"`
	// Empty to indicate default
	DatabaseFile string `json:"databaseFile"`
	// Empty to indicate default
	GeneratedLocation string `json:"generatedLocation"`
}

type ShortVersion struct {
	Shorthash string `json:"shorthash"`
	URL       string `json:"url"`
}

type StashBox struct {
	Endpoint string `json:"endpoint"`
	APIKey   string `json:"api_key"`
	Name     string `json:"name"`
}

// If neither performer_ids nor performer_names are set, tag all performers
type StashBoxBatchPerformerTagInput struct {
	// Stash endpoint to use for the performer tagging
	Endpoint int `json:"endpoint"`
	// Fields to exclude when executing the performer tagging
	ExcludeFields []string `json:"exclude_fields"`
	// Refresh performers already tagged by StashBox if true. Only tag performers with no StashBox tagging if false
	Refresh bool `json:"refresh"`
	// If set, only tag these performer ids
	PerformerIds []string `json:"performer_ids"`
	// If set, only tag these performer names
	PerformerNames []string `json:"performer_names"`
}

type StashBoxDraftSubmissionInput struct {
	ID            string `json:"id"`
	StashBoxIndex int    `json:"stash_box_index"`
}

type StashBoxFingerprint struct {
	Algorithm string `json:"algorithm"`
	Hash      string `json:"hash"`
	Duration  int    `json:"duration"`
}

type StashBoxFingerprintSubmissionInput struct {
	SceneIds      []string `json:"scene_ids"`
	StashBoxIndex int      `json:"stash_box_index"`
}

type StashBoxInput struct {
	Endpoint string `json:"endpoint"`
	APIKey   string `json:"api_key"`
	Name     string `json:"name"`
}

type StashBoxPerformerQueryInput struct {
	// Index of the configured stash-box instance to use
	StashBoxIndex int `json:"stash_box_index"`
	// Instructs query by scene fingerprints
	PerformerIds []string `json:"performer_ids"`
	// Query by query string
	Q *string `json:"q"`
}

type StashBoxPerformerQueryResult struct {
	Query   string              `json:"query"`
	Results []*ScrapedPerformer `json:"results"`
}

type StashBoxSceneQueryInput struct {
	// Index of the configured stash-box instance to use
	StashBoxIndex int `json:"stash_box_index"`
	// Instructs query by scene fingerprints
	SceneIds []string `json:"scene_ids"`
	// Query by query string
	Q *string `json:"q"`
}

type StashBoxValidationResult struct {
	Valid  bool   `json:"valid"`
	Status string `json:"status"`
}

type StashConfig struct {
	Path         string `json:"path"`
	ExcludeVideo bool   `json:"excludeVideo"`
	ExcludeImage bool   `json:"excludeImage"`
}

// Stash configuration details
type StashConfigInput struct {
	Path         string `json:"path"`
	ExcludeVideo bool   `json:"excludeVideo"`
	ExcludeImage bool   `json:"excludeImage"`
}

type StashIDInput struct {
	Endpoint string `json:"endpoint"`
	StashID  string `json:"stash_id"`
}

type StatsResultType struct {
	SceneCount     int     `json:"scene_count"`
	ScenesSize     float64 `json:"scenes_size"`
	ScenesDuration float64 `json:"scenes_duration"`
	ImageCount     int     `json:"image_count"`
	ImagesSize     float64 `json:"images_size"`
	GalleryCount   int     `json:"gallery_count"`
	PerformerCount int     `json:"performer_count"`
	StudioCount    int     `json:"studio_count"`
	MovieCount     int     `json:"movie_count"`
	TagCount       int     `json:"tag_count"`
}

type StringCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type StudioCreateInput struct {
	Name     string  `json:"name"`
	URL      *string `json:"url"`
	ParentID *string `json:"parent_id"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image"`
	StashIds      []*StashIDInput `json:"stash_ids"`
	Rating        *int            `json:"rating"`
	Details       *string         `json:"details"`
	Aliases       []string        `json:"aliases"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag"`
}

type StudioDestroyInput struct {
	ID string `json:"id"`
}

type StudioFilterType struct {
	And     *StudioFilterType     `json:"AND"`
	Or      *StudioFilterType     `json:"OR"`
	Not     *StudioFilterType     `json:"NOT"`
	Name    *StringCriterionInput `json:"name"`
	Details *StringCriterionInput `json:"details"`
	// Filter to only include studios with this parent studio
	Parents *MultiCriterionInput `json:"parents"`
	// Filter by StashID
	StashID *StringCriterionInput `json:"stash_id"`
	// Filter to only include studios missing this property
	IsMissing *string `json:"is_missing"`
	// Filter by rating
	Rating *IntCriterionInput `json:"rating"`
	// Filter by scene count
	SceneCount *IntCriterionInput `json:"scene_count"`
	// Filter by image count
	ImageCount *IntCriterionInput `json:"image_count"`
	// Filter by gallery count
	GalleryCount *IntCriterionInput `json:"gallery_count"`
	// Filter by url
	URL *StringCriterionInput `json:"url"`
	// Filter by studio aliases
	Aliases *StringCriterionInput `json:"aliases"`
	// Filter by autotag ignore value
	IgnoreAutoTag *bool `json:"ignore_auto_tag"`
}

type StudioUpdateInput struct {
	ID       string  `json:"id"`
	Name     *string `json:"name"`
	URL      *string `json:"url"`
	ParentID *string `json:"parent_id"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image"`
	StashIds      []*StashIDInput `json:"stash_ids"`
	Rating        *int            `json:"rating"`
	Details       *string         `json:"details"`
	Aliases       []string        `json:"aliases"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag"`
}

type SystemStatus struct {
	DatabaseSchema *int             `json:"databaseSchema"`
	DatabasePath   *string          `json:"databasePath"`
	ConfigPath     *string          `json:"configPath"`
	AppSchema      int              `json:"appSchema"`
	Status         SystemStatusEnum `json:"status"`
}

type TagCreateInput struct {
	Name          string   `json:"name"`
	Aliases       []string `json:"aliases"`
	IgnoreAutoTag *bool    `json:"ignore_auto_tag"`
	// This should be a URL or a base64 encoded data URL
	Image     *string  `json:"image"`
	ParentIds []string `json:"parent_ids"`
	ChildIds  []string `json:"child_ids"`
}

type TagDestroyInput struct {
	ID string `json:"id"`
}

type TagFilterType struct {
	And *TagFilterType `json:"AND"`
	Or  *TagFilterType `json:"OR"`
	Not *TagFilterType `json:"NOT"`
	// Filter by tag name
	Name *StringCriterionInput `json:"name"`
	// Filter by tag aliases
	Aliases *StringCriterionInput `json:"aliases"`
	// Filter to only include tags missing this property
	IsMissing *string `json:"is_missing"`
	// Filter by number of scenes with this tag
	SceneCount *IntCriterionInput `json:"scene_count"`
	// Filter by number of images with this tag
	ImageCount *IntCriterionInput `json:"image_count"`
	// Filter by number of galleries with this tag
	GalleryCount *IntCriterionInput `json:"gallery_count"`
	// Filter by number of performers with this tag
	PerformerCount *IntCriterionInput `json:"performer_count"`
	// Filter by number of markers with this tag
	MarkerCount *IntCriterionInput `json:"marker_count"`
	// Filter by parent tags
	Parents *HierarchicalMultiCriterionInput `json:"parents"`
	// Filter by child tags
	Children *HierarchicalMultiCriterionInput `json:"children"`
	// Filter by number of parent tags the tag has
	ParentCount *IntCriterionInput `json:"parent_count"`
	// Filter by number f child tags the tag has
	ChildCount *IntCriterionInput `json:"child_count"`
	// Filter by autotag ignore value
	IgnoreAutoTag *bool `json:"ignore_auto_tag"`
}

type TagUpdateInput struct {
	ID            string   `json:"id"`
	Name          *string  `json:"name"`
	Aliases       []string `json:"aliases"`
	IgnoreAutoTag *bool    `json:"ignore_auto_tag"`
	// This should be a URL or a base64 encoded data URL
	Image     *string  `json:"image"`
	ParentIds []string `json:"parent_ids"`
	ChildIds  []string `json:"child_ids"`
}

type TagsMergeInput struct {
	Source      []string `json:"source"`
	Destination string   `json:"destination"`
}

type Version struct {
	Version   *string `json:"version"`
	Hash      string  `json:"hash"`
	BuildTime string  `json:"build_time"`
}

type BulkUpdateIDMode string

const (
	BulkUpdateIDModeSet    BulkUpdateIDMode = "SET"
	BulkUpdateIDModeAdd    BulkUpdateIDMode = "ADD"
	BulkUpdateIDModeRemove BulkUpdateIDMode = "REMOVE"
)

var AllBulkUpdateIDMode = []BulkUpdateIDMode{
	BulkUpdateIDModeSet,
	BulkUpdateIDModeAdd,
	BulkUpdateIDModeRemove,
}

func (e BulkUpdateIDMode) IsValid() bool {
	switch e {
	case BulkUpdateIDModeSet, BulkUpdateIDModeAdd, BulkUpdateIDModeRemove:
		return true
	}
	return false
}

func (e BulkUpdateIDMode) String() string {
	return string(e)
}

func (e *BulkUpdateIDMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BulkUpdateIDMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BulkUpdateIdMode", str)
	}
	return nil
}

func (e BulkUpdateIDMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CriterionModifier string

const (
	// =
	CriterionModifierEquals CriterionModifier = "EQUALS"
	// !=
	CriterionModifierNotEquals CriterionModifier = "NOT_EQUALS"
	// >
	CriterionModifierGreaterThan CriterionModifier = "GREATER_THAN"
	// <
	CriterionModifierLessThan CriterionModifier = "LESS_THAN"
	// IS NULL
	CriterionModifierIsNull CriterionModifier = "IS_NULL"
	// IS NOT NULL
	CriterionModifierNotNull CriterionModifier = "NOT_NULL"
	// INCLUDES ALL
	CriterionModifierIncludesAll CriterionModifier = "INCLUDES_ALL"
	CriterionModifierIncludes    CriterionModifier = "INCLUDES"
	CriterionModifierExcludes    CriterionModifier = "EXCLUDES"
	// MATCHES REGEX
	CriterionModifierMatchesRegex CriterionModifier = "MATCHES_REGEX"
	// NOT MATCHES REGEX
	CriterionModifierNotMatchesRegex CriterionModifier = "NOT_MATCHES_REGEX"
	// >= AND <=
	CriterionModifierBetween CriterionModifier = "BETWEEN"
	// < OR >
	CriterionModifierNotBetween CriterionModifier = "NOT_BETWEEN"
)

var AllCriterionModifier = []CriterionModifier{
	CriterionModifierEquals,
	CriterionModifierNotEquals,
	CriterionModifierGreaterThan,
	CriterionModifierLessThan,
	CriterionModifierIsNull,
	CriterionModifierNotNull,
	CriterionModifierIncludesAll,
	CriterionModifierIncludes,
	CriterionModifierExcludes,
	CriterionModifierMatchesRegex,
	CriterionModifierNotMatchesRegex,
	CriterionModifierBetween,
	CriterionModifierNotBetween,
}

func (e CriterionModifier) IsValid() bool {
	switch e {
	case CriterionModifierEquals, CriterionModifierNotEquals, CriterionModifierGreaterThan, CriterionModifierLessThan, CriterionModifierIsNull, CriterionModifierNotNull, CriterionModifierIncludesAll, CriterionModifierIncludes, CriterionModifierExcludes, CriterionModifierMatchesRegex, CriterionModifierNotMatchesRegex, CriterionModifierBetween, CriterionModifierNotBetween:
		return true
	}
	return false
}

func (e CriterionModifier) String() string {
	return string(e)
}

func (e *CriterionModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CriterionModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CriterionModifier", str)
	}
	return nil
}

func (e CriterionModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilterMode string

const (
	FilterModeScenes       FilterMode = "SCENES"
	FilterModePerformers   FilterMode = "PERFORMERS"
	FilterModeStudios      FilterMode = "STUDIOS"
	FilterModeGalleries    FilterMode = "GALLERIES"
	FilterModeSceneMarkers FilterMode = "SCENE_MARKERS"
	FilterModeMovies       FilterMode = "MOVIES"
	FilterModeTags         FilterMode = "TAGS"
	FilterModeImages       FilterMode = "IMAGES"
)

var AllFilterMode = []FilterMode{
	FilterModeScenes,
	FilterModePerformers,
	FilterModeStudios,
	FilterModeGalleries,
	FilterModeSceneMarkers,
	FilterModeMovies,
	FilterModeTags,
	FilterModeImages,
}

func (e FilterMode) IsValid() bool {
	switch e {
	case FilterModeScenes, FilterModePerformers, FilterModeStudios, FilterModeGalleries, FilterModeSceneMarkers, FilterModeMovies, FilterModeTags, FilterModeImages:
		return true
	}
	return false
}

func (e FilterMode) String() string {
	return string(e)
}

func (e *FilterMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterMode", str)
	}
	return nil
}

func (e FilterMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderEnum string

const (
	GenderEnumMale              GenderEnum = "MALE"
	GenderEnumFemale            GenderEnum = "FEMALE"
	GenderEnumTransgenderMale   GenderEnum = "TRANSGENDER_MALE"
	GenderEnumTransgenderFemale GenderEnum = "TRANSGENDER_FEMALE"
	GenderEnumIntersex          GenderEnum = "INTERSEX"
	GenderEnumNonBinary         GenderEnum = "NON_BINARY"
)

var AllGenderEnum = []GenderEnum{
	GenderEnumMale,
	GenderEnumFemale,
	GenderEnumTransgenderMale,
	GenderEnumTransgenderFemale,
	GenderEnumIntersex,
	GenderEnumNonBinary,
}

func (e GenderEnum) IsValid() bool {
	switch e {
	case GenderEnumMale, GenderEnumFemale, GenderEnumTransgenderMale, GenderEnumTransgenderFemale, GenderEnumIntersex, GenderEnumNonBinary:
		return true
	}
	return false
}

func (e GenderEnum) String() string {
	return string(e)
}

func (e *GenderEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderEnum", str)
	}
	return nil
}

func (e GenderEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HashAlgorithm string

const (
	HashAlgorithmMd5 HashAlgorithm = "MD5"
	// oshash
	HashAlgorithmOshash HashAlgorithm = "OSHASH"
)

var AllHashAlgorithm = []HashAlgorithm{
	HashAlgorithmMd5,
	HashAlgorithmOshash,
}

func (e HashAlgorithm) IsValid() bool {
	switch e {
	case HashAlgorithmMd5, HashAlgorithmOshash:
		return true
	}
	return false
}

func (e HashAlgorithm) String() string {
	return string(e)
}

func (e *HashAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HashAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HashAlgorithm", str)
	}
	return nil
}

func (e HashAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IdentifyFieldStrategy string

const (
	// Never sets the field value
	IdentifyFieldStrategyIgnore IdentifyFieldStrategy = "IGNORE"
	// For multi-value fields, merge with existing.
	// For single-value fields, ignore if already set
	IdentifyFieldStrategyMerge IdentifyFieldStrategy = "MERGE"
	// Always replaces the value if a value is found.
	//   For multi-value fields, any existing values are removed and replaced with the
	//   scraped values.
	IdentifyFieldStrategyOverwrite IdentifyFieldStrategy = "OVERWRITE"
)

var AllIdentifyFieldStrategy = []IdentifyFieldStrategy{
	IdentifyFieldStrategyIgnore,
	IdentifyFieldStrategyMerge,
	IdentifyFieldStrategyOverwrite,
}

func (e IdentifyFieldStrategy) IsValid() bool {
	switch e {
	case IdentifyFieldStrategyIgnore, IdentifyFieldStrategyMerge, IdentifyFieldStrategyOverwrite:
		return true
	}
	return false
}

func (e IdentifyFieldStrategy) String() string {
	return string(e)
}

func (e *IdentifyFieldStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentifyFieldStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentifyFieldStrategy", str)
	}
	return nil
}

func (e IdentifyFieldStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageLightboxDisplayMode string

const (
	ImageLightboxDisplayModeOriginal ImageLightboxDisplayMode = "ORIGINAL"
	ImageLightboxDisplayModeFitXy    ImageLightboxDisplayMode = "FIT_XY"
	ImageLightboxDisplayModeFitX     ImageLightboxDisplayMode = "FIT_X"
)

var AllImageLightboxDisplayMode = []ImageLightboxDisplayMode{
	ImageLightboxDisplayModeOriginal,
	ImageLightboxDisplayModeFitXy,
	ImageLightboxDisplayModeFitX,
}

func (e ImageLightboxDisplayMode) IsValid() bool {
	switch e {
	case ImageLightboxDisplayModeOriginal, ImageLightboxDisplayModeFitXy, ImageLightboxDisplayModeFitX:
		return true
	}
	return false
}

func (e ImageLightboxDisplayMode) String() string {
	return string(e)
}

func (e *ImageLightboxDisplayMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageLightboxDisplayMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageLightboxDisplayMode", str)
	}
	return nil
}

func (e ImageLightboxDisplayMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageLightboxScrollMode string

const (
	ImageLightboxScrollModeZoom ImageLightboxScrollMode = "ZOOM"
	ImageLightboxScrollModePanY ImageLightboxScrollMode = "PAN_Y"
)

var AllImageLightboxScrollMode = []ImageLightboxScrollMode{
	ImageLightboxScrollModeZoom,
	ImageLightboxScrollModePanY,
}

func (e ImageLightboxScrollMode) IsValid() bool {
	switch e {
	case ImageLightboxScrollModeZoom, ImageLightboxScrollModePanY:
		return true
	}
	return false
}

func (e ImageLightboxScrollMode) String() string {
	return string(e)
}

func (e *ImageLightboxScrollMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageLightboxScrollMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageLightboxScrollMode", str)
	}
	return nil
}

func (e ImageLightboxScrollMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImportDuplicateEnum string

const (
	ImportDuplicateEnumIgnore    ImportDuplicateEnum = "IGNORE"
	ImportDuplicateEnumOverwrite ImportDuplicateEnum = "OVERWRITE"
	ImportDuplicateEnumFail      ImportDuplicateEnum = "FAIL"
)

var AllImportDuplicateEnum = []ImportDuplicateEnum{
	ImportDuplicateEnumIgnore,
	ImportDuplicateEnumOverwrite,
	ImportDuplicateEnumFail,
}

func (e ImportDuplicateEnum) IsValid() bool {
	switch e {
	case ImportDuplicateEnumIgnore, ImportDuplicateEnumOverwrite, ImportDuplicateEnumFail:
		return true
	}
	return false
}

func (e ImportDuplicateEnum) String() string {
	return string(e)
}

func (e *ImportDuplicateEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportDuplicateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportDuplicateEnum", str)
	}
	return nil
}

func (e ImportDuplicateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImportMissingRefEnum string

const (
	ImportMissingRefEnumIgnore ImportMissingRefEnum = "IGNORE"
	ImportMissingRefEnumFail   ImportMissingRefEnum = "FAIL"
	ImportMissingRefEnumCreate ImportMissingRefEnum = "CREATE"
)

var AllImportMissingRefEnum = []ImportMissingRefEnum{
	ImportMissingRefEnumIgnore,
	ImportMissingRefEnumFail,
	ImportMissingRefEnumCreate,
}

func (e ImportMissingRefEnum) IsValid() bool {
	switch e {
	case ImportMissingRefEnumIgnore, ImportMissingRefEnumFail, ImportMissingRefEnumCreate:
		return true
	}
	return false
}

func (e ImportMissingRefEnum) String() string {
	return string(e)
}

func (e *ImportMissingRefEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportMissingRefEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportMissingRefEnum", str)
	}
	return nil
}

func (e ImportMissingRefEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JobStatus string

const (
	JobStatusReady     JobStatus = "READY"
	JobStatusRunning   JobStatus = "RUNNING"
	JobStatusFinished  JobStatus = "FINISHED"
	JobStatusStopping  JobStatus = "STOPPING"
	JobStatusCancelled JobStatus = "CANCELLED"
)

var AllJobStatus = []JobStatus{
	JobStatusReady,
	JobStatusRunning,
	JobStatusFinished,
	JobStatusStopping,
	JobStatusCancelled,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusReady, JobStatusRunning, JobStatusFinished, JobStatusStopping, JobStatusCancelled:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JobStatusUpdateType string

const (
	JobStatusUpdateTypeAdd    JobStatusUpdateType = "ADD"
	JobStatusUpdateTypeRemove JobStatusUpdateType = "REMOVE"
	JobStatusUpdateTypeUpdate JobStatusUpdateType = "UPDATE"
)

var AllJobStatusUpdateType = []JobStatusUpdateType{
	JobStatusUpdateTypeAdd,
	JobStatusUpdateTypeRemove,
	JobStatusUpdateTypeUpdate,
}

func (e JobStatusUpdateType) IsValid() bool {
	switch e {
	case JobStatusUpdateTypeAdd, JobStatusUpdateTypeRemove, JobStatusUpdateTypeUpdate:
		return true
	}
	return false
}

func (e JobStatusUpdateType) String() string {
	return string(e)
}

func (e *JobStatusUpdateType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatusUpdateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatusUpdateType", str)
	}
	return nil
}

func (e JobStatusUpdateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LogLevel string

const (
	LogLevelTrace    LogLevel = "Trace"
	LogLevelDebug    LogLevel = "Debug"
	LogLevelInfo     LogLevel = "Info"
	LogLevelProgress LogLevel = "Progress"
	LogLevelWarning  LogLevel = "Warning"
	LogLevelError    LogLevel = "Error"
)

var AllLogLevel = []LogLevel{
	LogLevelTrace,
	LogLevelDebug,
	LogLevelInfo,
	LogLevelProgress,
	LogLevelWarning,
	LogLevelError,
}

func (e LogLevel) IsValid() bool {
	switch e {
	case LogLevelTrace, LogLevelDebug, LogLevelInfo, LogLevelProgress, LogLevelWarning, LogLevelError:
		return true
	}
	return false
}

func (e LogLevel) String() string {
	return string(e)
}

func (e *LogLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogLevel", str)
	}
	return nil
}

func (e LogLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreviewPreset string

const (
	// X264_ULTRAFAST
	PreviewPresetUltrafast PreviewPreset = "ultrafast"
	// X264_VERYFAST
	PreviewPresetVeryfast PreviewPreset = "veryfast"
	// X264_FAST
	PreviewPresetFast PreviewPreset = "fast"
	// X264_MEDIUM
	PreviewPresetMedium PreviewPreset = "medium"
	// X264_SLOW
	PreviewPresetSlow PreviewPreset = "slow"
	// X264_SLOWER
	PreviewPresetSlower PreviewPreset = "slower"
	// X264_VERYSLOW
	PreviewPresetVeryslow PreviewPreset = "veryslow"
)

var AllPreviewPreset = []PreviewPreset{
	PreviewPresetUltrafast,
	PreviewPresetVeryfast,
	PreviewPresetFast,
	PreviewPresetMedium,
	PreviewPresetSlow,
	PreviewPresetSlower,
	PreviewPresetVeryslow,
}

func (e PreviewPreset) IsValid() bool {
	switch e {
	case PreviewPresetUltrafast, PreviewPresetVeryfast, PreviewPresetFast, PreviewPresetMedium, PreviewPresetSlow, PreviewPresetSlower, PreviewPresetVeryslow:
		return true
	}
	return false
}

func (e PreviewPreset) String() string {
	return string(e)
}

func (e *PreviewPreset) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreviewPreset(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PreviewPreset", str)
	}
	return nil
}

func (e PreviewPreset) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ResolutionEnum string

const (
	// 144p
	ResolutionEnumVeryLow ResolutionEnum = "VERY_LOW"
	// 240p
	ResolutionEnumLow ResolutionEnum = "LOW"
	// 360p
	ResolutionEnumR360p ResolutionEnum = "R360P"
	// 480p
	ResolutionEnumStandard ResolutionEnum = "STANDARD"
	// 540p
	ResolutionEnumWebHd ResolutionEnum = "WEB_HD"
	// 720p
	ResolutionEnumStandardHd ResolutionEnum = "STANDARD_HD"
	// 1080p
	ResolutionEnumFullHd ResolutionEnum = "FULL_HD"
	// 1440p
	ResolutionEnumQuadHd ResolutionEnum = "QUAD_HD"
	// 1920p
	ResolutionEnumVrHd ResolutionEnum = "VR_HD"
	// 4k
	ResolutionEnumFourK ResolutionEnum = "FOUR_K"
	// 5k
	ResolutionEnumFiveK ResolutionEnum = "FIVE_K"
	// 6k
	ResolutionEnumSixK ResolutionEnum = "SIX_K"
	// 8k
	ResolutionEnumEightK ResolutionEnum = "EIGHT_K"
)

var AllResolutionEnum = []ResolutionEnum{
	ResolutionEnumVeryLow,
	ResolutionEnumLow,
	ResolutionEnumR360p,
	ResolutionEnumStandard,
	ResolutionEnumWebHd,
	ResolutionEnumStandardHd,
	ResolutionEnumFullHd,
	ResolutionEnumQuadHd,
	ResolutionEnumVrHd,
	ResolutionEnumFourK,
	ResolutionEnumFiveK,
	ResolutionEnumSixK,
	ResolutionEnumEightK,
}

func (e ResolutionEnum) IsValid() bool {
	switch e {
	case ResolutionEnumVeryLow, ResolutionEnumLow, ResolutionEnumR360p, ResolutionEnumStandard, ResolutionEnumWebHd, ResolutionEnumStandardHd, ResolutionEnumFullHd, ResolutionEnumQuadHd, ResolutionEnumVrHd, ResolutionEnumFourK, ResolutionEnumFiveK, ResolutionEnumSixK, ResolutionEnumEightK:
		return true
	}
	return false
}

func (e ResolutionEnum) String() string {
	return string(e)
}

func (e *ResolutionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResolutionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResolutionEnum", str)
	}
	return nil
}

func (e ResolutionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of the content a scraper generates
type ScrapeContentType string

const (
	ScrapeContentTypeGallery   ScrapeContentType = "GALLERY"
	ScrapeContentTypeMovie     ScrapeContentType = "MOVIE"
	ScrapeContentTypePerformer ScrapeContentType = "PERFORMER"
	ScrapeContentTypeScene     ScrapeContentType = "SCENE"
)

var AllScrapeContentType = []ScrapeContentType{
	ScrapeContentTypeGallery,
	ScrapeContentTypeMovie,
	ScrapeContentTypePerformer,
	ScrapeContentTypeScene,
}

func (e ScrapeContentType) IsValid() bool {
	switch e {
	case ScrapeContentTypeGallery, ScrapeContentTypeMovie, ScrapeContentTypePerformer, ScrapeContentTypeScene:
		return true
	}
	return false
}

func (e ScrapeContentType) String() string {
	return string(e)
}

func (e *ScrapeContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScrapeContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScrapeContentType", str)
	}
	return nil
}

func (e ScrapeContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScrapeType string

const (
	// From text query
	ScrapeTypeName ScrapeType = "NAME"
	// From existing object
	ScrapeTypeFragment ScrapeType = "FRAGMENT"
	// From URL
	ScrapeTypeURL ScrapeType = "URL"
)

var AllScrapeType = []ScrapeType{
	ScrapeTypeName,
	ScrapeTypeFragment,
	ScrapeTypeURL,
}

func (e ScrapeType) IsValid() bool {
	switch e {
	case ScrapeTypeName, ScrapeTypeFragment, ScrapeTypeURL:
		return true
	}
	return false
}

func (e ScrapeType) String() string {
	return string(e)
}

func (e *ScrapeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScrapeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScrapeType", str)
	}
	return nil
}

func (e ScrapeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StreamingResolutionEnum string

const (
	// 240p
	StreamingResolutionEnumLow StreamingResolutionEnum = "LOW"
	// 480p
	StreamingResolutionEnumStandard StreamingResolutionEnum = "STANDARD"
	// 720p
	StreamingResolutionEnumStandardHd StreamingResolutionEnum = "STANDARD_HD"
	// 1080p
	StreamingResolutionEnumFullHd StreamingResolutionEnum = "FULL_HD"
	// 4k
	StreamingResolutionEnumFourK StreamingResolutionEnum = "FOUR_K"
	// Original
	StreamingResolutionEnumOriginal StreamingResolutionEnum = "ORIGINAL"
)

var AllStreamingResolutionEnum = []StreamingResolutionEnum{
	StreamingResolutionEnumLow,
	StreamingResolutionEnumStandard,
	StreamingResolutionEnumStandardHd,
	StreamingResolutionEnumFullHd,
	StreamingResolutionEnumFourK,
	StreamingResolutionEnumOriginal,
}

func (e StreamingResolutionEnum) IsValid() bool {
	switch e {
	case StreamingResolutionEnumLow, StreamingResolutionEnumStandard, StreamingResolutionEnumStandardHd, StreamingResolutionEnumFullHd, StreamingResolutionEnumFourK, StreamingResolutionEnumOriginal:
		return true
	}
	return false
}

func (e StreamingResolutionEnum) String() string {
	return string(e)
}

func (e *StreamingResolutionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamingResolutionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamingResolutionEnum", str)
	}
	return nil
}

func (e StreamingResolutionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SystemStatusEnum string

const (
	SystemStatusEnumSetup          SystemStatusEnum = "SETUP"
	SystemStatusEnumNeedsMigration SystemStatusEnum = "NEEDS_MIGRATION"
	SystemStatusEnumOk             SystemStatusEnum = "OK"
)

var AllSystemStatusEnum = []SystemStatusEnum{
	SystemStatusEnumSetup,
	SystemStatusEnumNeedsMigration,
	SystemStatusEnumOk,
}

func (e SystemStatusEnum) IsValid() bool {
	switch e {
	case SystemStatusEnumSetup, SystemStatusEnumNeedsMigration, SystemStatusEnumOk:
		return true
	}
	return false
}

func (e SystemStatusEnum) String() string {
	return string(e)
}

func (e *SystemStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemStatusEnum", str)
	}
	return nil
}

func (e SystemStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
